# Algoritmos

Essa pergunta talvez j√° tenha passado pela sua cabe√ßa ao olhar para os c√≥digos que desenvolveu. E √© natural que seja assim, pois a efici√™ncia de um algoritmo √© um dos principais requisitos n√£o funcionais listados em levantamentos de requisitos, tanto por clientes quanto por membros das equipes de desenvolvimento.

Uma pessoa usu√°ria de um site n√£o quer que sua busca por determinada informa√ß√£o demore muito tempo para trazer um retorno. Por exemplo, n√£o √© frustrante quando algum programa causa lentid√£o √† nossa m√°quina em fun√ß√£o da quantidade de recursos que consome!? üò†

Entretanto, n√£o √© somente em experi√™ncia da pessoa usu√°ria que a efici√™ncia de um algoritmo se mostra importante. H√° diversos projetos e pesquisas cient√≠ficas que dependem, por exemplo, do processamento e armazenamento de bases enormes de dados, e que dependem de investimentos financeiros elevados.

Por esse motivo, √© fundamental que as pessoas desenvolvedoras sejam capazes de aumentar a efici√™ncia de seus algoritmos, reduzindo custos envolvidos e entregando a resolu√ß√£o de problemas.

## Voc√™ ser√° capaz de

- Descrever a capacidade de analisar o desempenho de um algoritmo como importante para processos seletivos de Big Techs, como Google, Amazon, Facebook, etc.

- Definir o que √© algoritmo;

- Definir o que √© um algoritmo correto;

- Compreender a import√¢ncia da an√°lise de algoritmos;

- Definir Ordem de Complexidade, ou Complexidade Assint√≥tica;

- Compreender as nota√ß√µes que representam a complexidade de um algoritmo, a saber: O(1), O(n), O(log n), O(n^2), O(n^3) e O(n!);

- Definir Complexidade de Tempo e Complexidade de Espa√ßo;

- Definir a categoria de problemas NP-Completo;

- Combinar fun√ß√µes matem√°ticas para analisar complexidade de algoritmos;

- Definir o melhor, o pior e o caso m√©dio de uma Ordem de Complexidade.

## Por que isso √© importante?
Em geral, para fun√ß√µes com um valor de entrada pequeno, n√£o costumamos nos importar com a efici√™ncia do algoritmo.

Entretanto, quando nossa fun√ß√£o tiver que lidar com valores de entrada muito grandes, por exemplo: mil valores ao mesmo tempo? Ou quem sabe milh√µes de valores? Nesses casos, a efici√™ncia do que estamos fazendo tornar-se importante e n√≥s, pessoas desenvolvedoras, precisamos ser capazes de lidar com esses cen√°rios!

‚ö†Ô∏è Aviso: Embora pare√ßa que estamos falando de quantidades irreais, h√° uma s√©rie de exemplos que comprovam que problemas gerados por entradas de dados grandiosas s√£o bastante comuns.

O famoso Discord, por exemplo, j√° enfrentou a demanda de ordenar alfabeticamente uma lista de amigos com at√© 250.000 pessoas. E voc√™ sabe o tempo m√°ximo que o algoritmo tinha pra rodar? Menos de um segundo e meio! Um desafio e tanto que p√¥de ser solucionado com o conhecimento sobre Algoritmos.

De olho na dica üëÄ: Esse conhecimento √© t√£o importante no mundo da tecnologia, que as famosas Big Techs como: Google, Amazon e Facebook, fazem processos seletivos nos quais a capacidade de fazer esse tipo de an√°lise √© obrigat√≥ria.

Em suma, quando cresce a escala, esse conhecimento se torna essencial. E com esse conhecimento voc√™ vai perceber a exist√™ncia de certos tipos de problemas que ainda n√£o t√™m solu√ß√£o, mesmo reunindo toda a capacidade computacional do planeta.

‚ö†Ô∏è Aviso: Parece exagero? Mas acredite, n√£o √©. Vamos seguir para o conte√∫do e isso ficar√° mais n√≠tido para voc√™. üôÇ

## O que √© um algoritmo?

Uma vez que usamos essa palavra com frequ√™ncia, √© preciso que tenhamos a defini√ß√£o bem n√≠tida para esse conceito, de modo a garantir que estamos partindo do mesmo ponto quando falamos de Complexidade Algor√≠tmica.

_‚ÄúInformalmente, um algoritmo √© qualquer procedimento computacional bem definido que toma algum valor ou conjunto de valores como entrada e produz algum valor ou conjunto de valores como sa√≠da. Portanto, um algoritmo √© uma sequ√™ncia de etapas computacionais que transformam a entrada na sa√≠da‚Äù (CLRS - Introduction to Algorithms)_

_‚ÄúUm algoritmo √© um conjunto de instru√ß√µes que realizam uma tarefa.‚Äù (BHARGAVA, ADITYA Y. - Entendendo Algoritmos)_

Basicamente, um algoritmo √© uma sequ√™ncia l√≥gica de passos bem definida (entrada, processamento e sa√≠da) que realiza determinada tarefa.

Pode parecer que usamos algoritmos somente para resolver problemas computacionais, entretanto, tamb√©m os utilizamos no nosso dia a dia! Observe alguns exemplos a seguir:

````
def sum_array(numbers):
    sum = 0
    for number in numbers:
        sum += number

    return sum
````

Por√©m, vamos supor que estamos falando de uma m√°quina padr√£o e sem mais nada rodando nela. Quanto tempo voc√™ imagina que o algoritmo vai demorar para executar? Um segundo? Dez segundos?

Temos mais um ‚Äúdepende‚Äù aqui, n√£o √© mesmo? O tempo de execu√ß√£o depende do tamanho do array passado por par√¢metro! Quanto maior o tamanho dele, mais tempo o algoritmo gastar√° em sua execu√ß√£o.

Dito isso, n√£o sabemos quanto tempo o algoritmo vai demorar para executar, pois vai depender de in√∫meros fatores que v√£o al√©m do nosso controle. Mas, uma coisa podemos afirmar: O tempo de execu√ß√£o dele √© proporcional ao tamanho do dado de entrada. Por exemplo:

````
# def sum_array(numbers):
  # ...

# Suponha que, para o array abaixo, o tempo de execu√ß√£o seja `n`
sum_array(array_com_dez_mil_numeros)

# Nesse caso, aqui o tempo de execu√ß√£o vai ser `10 * n`, ou `10n`, j√° que o array √© dez vezes maior que o anterior
sum_array(array_com_cem_mil_numeros)

# J√° esse √© dez mil vezes maior que o primeiro, ent√£o esse aqui executa em `100n`
sum_array(array_com_um_milh√£o_de_numeros)
````

Note que conforme aumentamos o valor da entrada, o tempo de execu√ß√£o do algoritmo aumenta proporcionalmente, de acordo com uma taxa.

√â isso que chamamos de complexidade: A taxa de crescimento do tempo de execu√ß√£o de um algoritmo; quanto maior √© essa taxa, maior √© seu tempo de execu√ß√£o e, portanto, maior sua complexidade.

No exemplo anterior, os valores de entrada podem variar, mas as propor√ß√µes n√£o: Um aumento no tamanho da entrada aumenta o tempo de execu√ß√£o na mesma propor√ß√£o.

Podemos dizer, em suma, que a Ordem de Complexidade nada mais √© do que a representa√ß√£o dessa propor√ß√£o (ou taxa) de crescimento. Dado que o algoritmo √© linearmente proporcional ao tempo de execu√ß√£o, dizemos que este √© um algoritmo linear.

Anota a√≠ üñä: A Ordem de Complexidade nada mais √© do que a representa√ß√£o dessa propor√ß√£o (ou taxa) de crescimento. Dado que o algoritmo √© linearmente proporcional ao tempo de execu√ß√£o, dizemos que este √© um algoritmo linear.

A fun√ß√£o matem√°tica que representa uma rela√ß√£o linear √© f(n) = n e a nota√ß√£o de Ordem de Complexidade para representar a taxa de crescimento do tempo de execu√ß√£o de um algoritmo √© dada por O(n), onde o n representa a quantidade de opera√ß√µes que o algoritmo vai realizar.

‚ö†Ô∏è Aviso: A partir de agora, sempre que falarmos sobre a Ordem de Complexidade n√£o iremos nos referir ao tempo em segundos que um algoritmo leva para ser executado, mas sim a quantidade de opera√ß√µes que ele realiza. üôÇ

A Ordem de Complexidade pode ser chamada, tamb√©m, de Complexidade Assint√≥tica.

# Complexidade de tempo e de espa√ßo

Anteriormente, dissemos que a complexidade de um algoritmo representa o crescimento de seu tempo de execu√ß√£o em fun√ß√£o de uma taxa, a quantidade de opera√ß√µes que ele realiza. Por√©m, quando falamos em complexidade, n√£o analisamos apenas o tempo, analisamos tamb√©m o espa√ßo gasto. Vejamos como isso funciona.

Observe o algoritmo a seguir:

````
def squared_array(numbers):
    array_of_squares = []
    for number in numbers:
        array_of_squares.append(number * number)

    return array_of_squares
````

Esse algoritmo recebe um array de n√∫meros, percorre esse array e retorna um novo com os n√∫meros ao quadrado. Ou seja, ele passa por todos os elementos desse array. Isso significa que se houver 10 n√∫meros na entrada de dados,por exemplo, ser√£o realizadas 10 opera√ß√µes; se houver 100 ser√£o realizadas 100 opera√ß√µes. O que isso representa em termos de complexidade?

Em rela√ß√£o √† Complexidade de Tempo, temos aqui uma taxa de crescimento linear, uma vez que o aumento no tamanho do array faz crescer proporcionalmente o tempo gasto na execu√ß√£o do algoritmo. Sendo assim, podemos afirmar que a Complexidade de Tempo aqui √© O(n), chamada geralmente tempo linear (Lembre-se que O faz refer√™ncia aqui a ordem de complexidade, enquanto (n) representa a f√≥rmula matem√°tica que diz sobre a taxa de crescimento do n√∫mero de opera√ß√µes).

Bem, como sabemos, esse algoritmo vai sempre nos retornar um array com o mesmo tamanho da entrada de dados, pois ele sempre devolve um novo arraycom todos os n√∫meros de entrada ao quadrado: se entrar um array de 10 n√∫meros, sair√° um de 10; se entrar um de 100, sair√° um de 100 e assim sucessivamente. Desse modo, conforme a entrada cresce, a sa√≠da tamb√©m cresce e, consequentemente, o espa√ßo ocupado por ela, o que implica dizer que sua Complexidade de Espa√ßo √© dada por O(n).

Recorde-se do algoritmo mencionado na se√ß√£o passada, da fun√ß√£o sum_array. Naquele caso, a Complexidade de Tempo tamb√©m era O(n), j√° que o tempo de execu√ß√£o crescia linearmente.

No caso de sum_array, mesmo que a entrada de dados fosse crescendo, sua sa√≠da nunca ocuparia mais espa√ßo, pois o retorno era sempre um n√∫mero s√≥. Sendo assim, sua Complexidade de Espa√ßo era constante e pode ser representada pela nota√ß√£o O(1).

Para finalizar, um ponto importante que deve ser ressaltado √© que quando calculamos a complexidade de espa√ßo n√£o levamos em considera√ß√£o o espa√ßo ocupado pela entrada, uma vez que o tamanho da entrada n√£o √© algo que podemos, com nosso algoritmo, influenciar.

Anota a√≠ üñä: Se falamos em ordem de complexidade sem especificar se √© de tempo ou de mem√≥ria, assuma que √© de tempo!

Que tal fazermos um exerc√≠cio para fixar esses conceitos? üòÑ

## Complexidade quadr√°tica

N√≥s j√° compreendemos o que √© e qual a nota√ß√£o que representa a Complexidade Algor√≠tmica. A partir de agora, vamos ver que, dependendo da forma como um algoritmo √© escrito, seu tempo de execu√ß√£o vai ser alterado de acordo com diferentes taxas de crescimento.

Nesta e nas pr√≥ximas se√ß√µes veremos como o ‚Äútempo de execu√ß√£o dos algoritmos cresce a taxas diferentes‚Äù (BHARGAVA, ADITYA Y.).

Observe o algoritmo abaixo:

````
# Os arrays t√™m sempre o mesmo tamanho
def multiply_arrays(array1, array2):
    result = []
    for number1 in array1:
        for number2 in array2:
            result.append(number1 + number2)

    return result
````

No algoritmo acima, s√£o recebidos dois arrays de tamanhos iguais e √© retornado um novo array, cujos elementos s√£o resultado da soma de cada um dos elementos do array1 com todos os elementos do array2.

Qual seria a taxa de crescimento do tempo de execu√ß√£o desse algoritmo?ü§î

Para cada n√∫mero do array1 ser somado com todos os n√∫meros contidos no array2, √© necess√°rio que o segundo seja percorrido por inteiro.

Isso significa que para array1 e array2 com duas posi√ß√µes, ser√£o necess√°rias 4 itera√ß√µes (ou opera√ß√µes), para o algoritmo concluir sua execu√ß√£o. Se cada uma das entradas tiver 3 elementos, ser√£o necess√°rias 9 opera√ß√µes para a conclus√£o da execu√ß√£o e assim sucessivamente.

Rode o exemplo abaixo para conferir:

````
def multiply_arrays(array1, array2):
    result = []
    number_of_iterations = 0

    for number1 in array1:
        print(f'Array 1: {number1}')
        for number2 in array2:
            print(f'Array 2: {number2}')
            result.append(number1 * number2)
            number_of_iterations += 1

    print(f'{number_of_iterations} itera√ß√µes!')
    return result


meu_array = [1, 2, 3, 4, 5]

multiply_arrays(meu_array, meu_array)
````
Para o exemplo acima, no qual as duas entradas continham 5 elementos, foram necess√°rias 25 opera√ß√µes para obtermos o resultado final!

Anota a√≠ üñä: conforme aumentamos o tamanho dos arrays de entrada, o n√∫mero de opera√ß√µes para a execu√ß√£o do algoritmo cresce ao quadrado. Isso significa que, para entradas de tamanho n, a quantidade de opera√ß√µes para executar o algoritmo √© de n¬≤. Sendo assim, a complexidade desse algoritmo √© dada por O(n¬≤) e a chamamos de Complexidade Quadr√°tica.

Com esses exemplos, percebemos que algoritmos diferentes crescem a taxas diferentes. Vamos, agora, fazer alguns exerc√≠cios para fixar melhor esses conceitos!

## Comparando complexidades

Relembrandoüß†:

A Ordem de Complexidade diz respeito √† taxa de crescimento do tempo de execu√ß√£o (ou espa√ßo de mem√≥ria ocupado) de um algoritmo, na medida em que aumentamos o tamanho da sua entrada;

Uma complexidade √© O(1) (constante), quando o tempo de execu√ß√£o do algoritmo independe do tamanho da entrada;

Uma complexidade √© O(n) (linear) quando a taxa de crescimento em seu tempo de execu√ß√£o √© linear: se aumentamos a entrada em 2 vezes, aumentamos o tempo de execu√ß√£o em 2 vezes;

Uma complexidade √© O(n¬≤) (quadr√°tica) quando a taxa de crescimento do tempo de execu√ß√£o do algoritmo √© quadr√°tica: se aumentamos a entrada em 2 vezes, aumentamos o tempo de execu√ß√£o em 4 (ou 2¬≤) vezes;

Uma complexidade √© O(n¬≥) (c√∫bica) quando a taxa de crescimento do tempo de execu√ß√£o do algoritmo √© c√∫bica: se aumentamos a entrada em 2 vezes, aumentamos o tempo de execu√ß√£o em 8 (2¬≥) vezes.

Falamos aqui de algoritmos O(n), O(n¬≤) e at√© de O(n¬≥). Mas, para ilustrar melhor a matem√°tica dos algoritmos, vamos mostrar o que eles significam de outra forma.

Observe, o gr√°fico abaixo e veja como o tempo de execu√ß√£o de um algoritmo c√∫bico cresce muito mais para uma entrada, muito menor que a do algoritmo linear:

Para exemplificar, vamos pensar do seguinte modo: para um algoritmo linear, com n = 1000, teremos mil opera√ß√µes a serem realizadas. Quando o algoritmo √© O(n¬≤), um n = 1000 gera um milh√£o de opera√ß√µes (ou n¬≤ de opera√ß√µes). Essa mesma quantidade (um milh√£o) para O(n¬≥), se atinge com n = 100.

Est√° entendendo como alguns algoritmos podem ficar rapidamente invi√°veis de se executar? Por isso, compreender a taxa de crescimento de um algoritmo √© t√£o importante!

A seguir, vamos explorar outros tipos de complexidades de algoritmos!

De olho na dicaüëÄ: Caso voc√™ se confunda com a quantidade de n√∫meros, rode exemplos na sua m√°quina contando o n√∫mero de itera√ß√µes! √â uma excelente forma de visualizar a complexidade acontecendo. E n√£o deixe de falar com a gente no Slack se algum exemplo estiver te confundindo!

## Complexidade Logar√≠tmica

Agora, vamos entender o que √© a Complexidade Logar√≠tmica. Mas, antes disso, √© preciso deixar n√≠tido que, apesar do termo potencialmente assustador, a Complexidade Logar√≠tmica n√£o exige c√°lculos matem√°ticos complicados para ser entendida. üôÇ

Representado pela nota√ß√£o O(log n), um algoritmo logar√≠tmico tem uma altera√ß√£o na taxa de execu√ß√£o que, geralmente, reduz pela metade o tempo de finaliza√ß√£o das itera√ß√µes ao reduzir pela metade o tamanho do input a cada itera√ß√£o.

Vamos refletir sobre isso:

Suponha que temos um algoritmo cuja entrada n √© igual a 4, se tivermos um algoritmo O(log n) a ser executado com essa entrada, teremos que fazer apenas 2 opera√ß√µes para execut√°-lo, pois log‚ÇÇn (l√™-se: ‚Äúlog de n na base 2‚Äù) √© igual a 2. Se a nossa entrada fosse o dobro, ou seja, 8 ter√≠amos que realizar apenas 3 opera√ß√µes para chegar ao fim da execu√ß√£o. Ao dobrar o valor da entrada novamente, com n igual a 16, ter√≠amos que realizar apenas 4 opera√ß√µes (log‚ÇÇn √© igual a 4) e assim sucessivamente.

Anota a√≠ üñä: O n√∫mero de opera√ß√µes para executar o algoritmo logar√≠tmico tem uma rela√ß√£o inversa ao tamanho da entrada: quanto maior ela √©, menor o n√∫mero de opera√ß√µes e, consequentemente, menor o tempo para a execu√ß√£o do algoritmo!

Voc√™ pode estar se perguntando: ‚ÄúMas como √© poss√≠vel criar um algoritmo com essa Ordem de Complexidade?‚Äùü§î

No exemplo a seguir, temos um algoritmo de busca bin√°ria que entenderemos em detalhes mais adiante. Por ora, basta compreender que esse algoritmo representa uma complexidade O(log n).

Suponha que vamos criar um algoritmo de lista telef√¥nica. Temos uma lista de nomes de tamanho n, ordenada em ordem alfab√©tica, e um nome x; devemos encontrar o n√∫mero de telefone da pessoa passada na entrada.

Suponha que vamos procurar pelo nome Tintim.Como faremos isso?

- Buscar na p√°gina (ou posi√ß√£o) da lista que tenha nomes come√ßando com a letra T;
- Escolher uma p√°gina aleat√≥ria da lista para abrir;
- Percebemos que ca√≠mos na posi√ß√£o da letra M;
- Percebemos que ca√≠mos na posi√ß√£o da letra M;
- Como M < T, na ordem alfab√©tica, ent√£o, devemos avan√ßar algumas posi√ß√µes para encontrar o T;
- Ent√£o, escolhemos uma p√°gina que est√° mais adiante;
- Percebemos que ca√≠mos na posi√ß√£o da letra V;
- Como V > T, na ordem alfab√©tica, ent√£o devemos voltar alguns posi√ß√µes;
- Vamos repetimos esse processo at√© encontrarmos o nome desejado.

Haveria outra forma de fazer essa pesquisa na lista telef√¥nica? Sim! N√≥s poder√≠amos passar por cada p√°gina, da letra A at√© a letra T para encontrar Tintim. Por√©m, o n√∫mero de opera√ß√µes necess√°rias para realizar isso seria muito maior do que aquele que usamos no exemplo acima!

Perceba o seguinte: o nosso alfabeto tem 26 letras e a letra T est√° na posi√ß√£o 20 dele. Se segu√≠ssemos o algoritmo de busca sequencial, passando sequencialmente pelas letras de A √† T, ter√≠amos que realizar 20 opera√ß√µes para encontrar o que est√°vamos procurando. Mas, se us√°ssemos o algoritmo de busca bin√°ria, que criamos acima, poder√≠amos resolver facilmente o problema de encontrar a letra T utilizando menos da metade das opera√ß√µes que uma busca sequencial demanda. Ou seja, poder√≠amos facilmente encontrar a letra T na lista telef√¥nica com 10 ou menos passos, obtendo, assim, um algoritmo de complexidade O(log n) para resolver o problema.

Para entender melhor a diferen√ßa entre um algoritmo de busca bin√°ria, logar√≠tmico, com um de busca sequencial, que √© linear, observe o gif abaixo.

Agora que j√° passamos pelo conceito de Complexidade Logar√≠tmica, vejamos o algoritmo de busca bin√°ria abaixo.

De olho na dicaüëÄ: √© altamente recomendado que voc√™ rode na sua m√°quina para entender melhor como funciona):

````
# A estrutura deve estar ordenada para que a busca bin√°ria funcione
def binary_search(numbers, target):
    # definir os √≠ndices
    start = 0
    end = len(numbers) - 1

    while start <= end: # os √≠ndices podem ser no m√°ximo iguais, o in√≠cio n√£o pode ultrapassar o fim
        mid = (start + end) // 2 # encontro o meio

        if numbers[mid] == target: # se o elemento do meio for o alvo, devolve a posi√ß√£o do meio
            return mid
        
        if target < numbers[mid]: # se o elemento for menor, atualiza o √≠ndice do fim
            end = mid - 1
        else: # caso contr√°rio, atualiza o √≠ndice do inicio
            start = mid + 1
    
    return -1 # N√£o encontrou? Retorna -1

numbers = [2, 3, 4, 10, 40]
target = 40

result = binary_search(numbers, target)
print(f"Elemento encontrado na posi√ß√£o: {result}")
````
Observe como, a cada itera√ß√£o, o algoritmo de busca bin√°ria corta o problema pela metade:

primeiro ele ‚Äúcorta‚Äù a lista em dois e pega o elemento do meio.
Depois ele ‚Äúcaminha‚Äù para o lado no elemento que procura esta e ‚Äúcorta‚Äù este lado novamente pela metade.
Anota a√≠ üñä: Quando cortamos a entrada pela metade, a cada itera√ß√£o, temos um padr√£o que segue a fun√ß√£o matem√°tica de logaritmo na base dois! Assim, nosso algoritmo √© O(log n).

Um logaritmo em base 2 representa o n√∫mero de vezes que um valor deve ser dividido pela metade para obter 1.

Dessa forma, sem precisarmos nos aprofundar na matem√°tica, conseguimos calcular a ordem de complexidade de um algoritmo deste tipo: Quando a entrada √© cortada pela metade a cada itera√ß√£o temos um comportamento logar√≠tmico!

Veja abaixo um gr√°fico que compara o tempo de execu√ß√£o de um algoritmo linear e um logar√≠tmico.

## Complexidade Exponencial e Fatorial

Essas complexidades caracterizam algoritmos que, para aumentos pequenos no tamanho da entrada, aumentam enormemente o n√∫mero de opera√ß√µes a serem realizadas para serem executados e, consequentemente, seu tempo de execu√ß√£o. A rela√ß√£o do tempo de execu√ß√£o/espa√ßo ocupado em cada caso √© a seguinte:

- Exponencial: 2‚Åø (O(2‚Åø));

- Fatorial: n! (O(n!)).

No caso de um algoritmo com Ordem de Complexidade Exponencial, para uma entrada de dados n que possui vinte elementos, o algoritmo realizar√° aproximadamente um milh√£o (ou 2¬≤‚Å∞) de opera√ß√µes. Para o caso fatorial, os mesmos vinte elementos rendem 24 quatrilh√µes de opera√ß√µes! (O n√∫mero exato √©: 2432902008176640000 opera√ß√µes üò®).

No caso de um algoritmo com Ordem de Complexidade Exponencial, para uma entrada de dados n que possui vinte elementos, o algoritmo realizar√° aproximadamente um milh√£o (ou 2¬≤‚Å∞) de opera√ß√µes. Para o caso fatorial, os mesmos vinte elementos rendem 24 quatrilh√µes de opera√ß√µes! (O n√∫mero exato √©: 2432902008176640000 opera√ß√µes üò®).

Voc√™ pode estar se perguntando: ‚ÄúMas por que algu√©m iria escrever um algoritmo de ordem de complexidade fatorial?!‚Äùü§î

Resposta: porque n√£o h√° outro algoritmo conhecido que resolve o problema. Pode parecer estranho, mas h√° problemas para os quais ainda n√£o possu√≠mos uma solu√ß√£o otimizada.

Um exemplo cl√°ssico √© o problema do Caixeiro-Viajante! Veja logo abaixo:

‚ÄúDada uma lista de cidades e a dist√¢ncia entre cada par de cidades, qual √© a rota mais curta poss√≠vel que visita todas as cidades exatamente uma vez e volta para a cidade de origem?‚Äù

A √∫nica solu√ß√£o exata conhecida para este problema √© a for√ßa bruta: testamos todas as possibilidades e escolher a menor rota.

Agora, imagine que o caixeiro-viajante tenha que passar por tr√™s cidades: Belo Horizonte, S√£o Paulo e Florian√≥polis. Ele tem as seguintes rotas poss√≠veis:

O n√∫mero de rotas para 3 cidades √© 3! == 3 * 2 * 1 = 6. Atualmente, o Brasil tem 5570 munic√≠pios. Se nosso caixeiro-viajante tivesse que passar por todos os munic√≠pios, isso daria a ele 5570 * 5569 * 5568 * ... * rotas.

Quantos milhares de anos um computador precisaria para rodar esse algoritmo nesse caso?!üò±

Algoritmos que n√£o t√™m solu√ß√£o conhecida em tempo polinomial, ou seja, cuja Ordem de Complexidade √© fatorial ou exponencial e s√£o possivelmente resolvidos somente com for√ßa bruta, pertencem a uma categoria de problemas na computa√ß√£o chamada problemas NP Completos.

De olho na dicaüëÄ: Se quiser conhecer mais sobre essa categoria de problemas, explore nossos recursos adicionais!

## Analisando algoritmos com v√°rias estruturas de repeti√ß√£o

Agora que j√° sabemos analisar a Ordem de Complexidade, vamos para alguns algoritmos.

Observe o algoritmo o abaixo:

````
def calculations(n):
    number1 = 0
    for n1 in range(n):
        number1 += n1

    number2 = 0
    for n1 in range(n):
       for n2 in range(n):
            number2 += n1 + n2

    number3 = 0
    for n1 in range(n):
       for n2 in range(n):
           for n3 in range(n):
               number3 += n1 + n2 + n3

    return number1, number2, number3

n1, n2, n3 = calculations(100)
print(f'{n1}, {n2}, {n3}')
````

Esse algoritmo tem tr√™s estruturas de repeti√ß√£o evidentes: uma linear, uma quadr√°tica e uma c√∫bica.

Qual √© a Ordem de Complexidade dele? ü§î

Resposta: A rigor, ela seria O(n + n¬≤ + n¬≥).

De olho na dicaüëÄ: Se os loops est√£o aninhados voc√™ os multiplica, e se est√£o paralelos voc√™ os soma.

Podemos pensar em alguns outros exemplos:

Um algoritmo de busca bin√°ria que roda tr√™s vezes teria O(3 * log n) de complexidade;

Um algoritmo que roda uma busca bin√°ria num array de tamanho n para cada elemento de um array de tamanho m teria O(m * log n) de complexidade.

No entanto, geralmente simplificam-se essas nota√ß√µes. Estamos vendo, ao longo dos nossos estudos, que ordens de complexidade diferentes, para entradas grandes, t√™m valores absurdamente diferentes.

Imagine escrever O(n! + log(n)). Ora, para uma entrada de tamanho 8 esse n√∫mero seria O(40320 + 3). Observe como o componente fatorial da equa√ß√£o, n! = 40320, domina completamente a ordem de complexidade. Nesse cen√°rio, dizemos que a complexidade menor √© desprez√≠vel e, ent√£o, a omitimos.

Anota a√≠ üñä: Para valores grandes, dizer a maior ordem de complexidade do conjunto j√° basta para uma boa an√°lise. Sendo assim, ao analisar v√°rias estruturas de repeti√ß√£o em paralelo, responda somente com o valor da estrutura que tiver maior ordem de complexidade na hora de fazer a sua an√°lise.

## Melhor caso, pior caso e caso m√©dio

H√° um √∫ltimo conceito importante para aprendermos aqui, antes de passarmos para a aula ao vivo e os exerc√≠cios!

Voc√™ ver√° mais para frente durante seu aprendizado aqui na Trybe, os termos ‚Äúmelhor caso‚Äù, ‚Äúpior caso‚Äù e ‚Äúcaso m√©dio‚Äù.

Eles significam o seguinte: ‚ÄúA depender da minha entrada, o meu algoritmo pode executar em O(1) ou O(n)‚Äú. Por exemplo, pense na busca sequencial:

````
def linear_search(numbers, target):
    n = len(numbers) # N ser√° a quantidade de elementos da lista
    for index in range(0, n): # vamos iterar a lista completa
        if numbers[index] == target: # se encontrar o elemento alvo, retorne a posi√ß√£o
            return index

    return -1 # N√£o encontrou? Retorne -1


print(linear_search([1, 2, 3], 2))  # sa√≠da: 1
print(linear_search([1, 2, 3], 4))  # sa√≠da: -1
````

Dizemos que, para entradas muito grandes, esse algoritmo √© O(n).

O que acontece, por√©m, caso tenhamos sorte e o n√∫mero que procuramos seja o primeiro do array?ü§î

Resposta: Nesse caso, mesmo para uma entrada infinita, nossa complexidade ser√° O(1). Esse √© o melhor caso desse algoritmo. De forma an√°loga, o pior caso √© o n√∫mero ser o √∫ltimo elemento do array, ou seja O(n).

Voc√™ pode estar se perguntando: ‚ÄúE o caso m√©dio‚Äù? ü§î

Resposta: Seria algo como O(n * 1/2), por exemplo. Nesse caso, o n√∫mero que procuramos est√° no meio da lista. Mas, para entradas muito grandes, aprendemos a desprezar os n√∫meros menos relevantes da soma, ent√£o, podemos simplificar e dizer que o caso m√©dio √© O(n) tamb√©m.

Diferentes algoritmos t√™m diferentes cen√°rios de melhor caso, pior caso e caso m√©dio. Veremos v√°rios exemplos disso ao longo das pr√≥ximas se√ß√µes.